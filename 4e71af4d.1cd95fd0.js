(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{142:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return b}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function u(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=o.a.createContext({}),l=function(e){var t=o.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):u(u({},t),e)),n},p=function(e){var t=l(e.components);return o.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=l(n),m=a,b=p["".concat(i,".").concat(m)]||p[m]||d[m]||r;return n?o.a.createElement(b,u(u({ref:t},s),{},{components:n})):o.a.createElement(b,u({ref:t},s))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var u={};for(var c in t)hasOwnProperty.call(t,c)&&(u[c]=t[c]);u.originalType=e,u.mdxType="string"==typeof e?e:a,i[1]=u;for(var s=2;s<r;s++)i[s]=n[s];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},95:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return u})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return l}));var a=n(3),o=n(7),r=(n(0),n(142)),i={id:"invalidation-from-mutations",title:"Invalidation from Mutations"},u={unversionedId:"guides&concepts/invalidation-from-mutations",id:"guides&concepts/invalidation-from-mutations",isDocsHomePage:!1,title:"Invalidation from Mutations",description:"Invalidating queries is only half the battle. Knowing when to invalidate them is the other half. Usually when a mutation in your app succeeds, it's VERY likely that there are related queries in your application that need to be invalidated and possibly refetched to account for the new changes from your mutation.",source:"@site/docs/guides&concepts/invalidation-from-mutations.md",slug:"/guides&concepts/invalidation-from-mutations",permalink:"/react-query-web-i18n/guides&concepts/invalidation-from-mutations",editUrl:"https://github.com/cangSDARM/react-query-web-i18n/docs/guides&concepts/invalidation-from-mutations.md",version:"current",lastUpdatedAt:1614595344,sidebar:"zhCN",previous:{title:"Query Invalidation",permalink:"/react-query-web-i18n/guides&concepts/query-invalidation"},next:{title:"Updates from Mutation Responses",permalink:"/react-query-web-i18n/guides&concepts/updates-from-mutation-responses"}},c=[],s={toc:c};function l(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Invalidating queries is only half the battle. Knowing ",Object(r.b)("strong",{parentName:"p"},"when")," to invalidate them is the other half. Usually when a mutation in your app succeeds, it's VERY likely that there are related queries in your application that need to be invalidated and possibly refetched to account for the new changes from your mutation."),Object(r.b)("p",null,"For example, assume we have a mutation to post a new todo:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"const mutation = useMutation(postTodo)\n")),Object(r.b)("p",null,"When a successful ",Object(r.b)("inlineCode",{parentName:"p"},"postTodo")," mutation happens, we likely want all ",Object(r.b)("inlineCode",{parentName:"p"},"todos")," queries to get invalidated and possibly refetched to show the new todo item. To do this, you can use ",Object(r.b)("inlineCode",{parentName:"p"},"useMutation"),"'s ",Object(r.b)("inlineCode",{parentName:"p"},"onSuccess")," options and the ",Object(r.b)("inlineCode",{parentName:"p"},"client"),"'s ",Object(r.b)("inlineCode",{parentName:"p"},"invalidateQueries")," function:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"import { useMutation, useQueryClient } from 'react-query'\n\nconst queryClient = useQueryClient()\n\n// When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key\nconst mutation = useMutation(addTodo, {\n  onSuccess: () => {\n    queryClient.invalidateQueries('todos')\n    queryClient.invalidateQueries('reminders')\n  },\n})\n")),Object(r.b)("p",null,"You can wire up your invalidations to happen using any of the callbacks available in the ",Object(r.b)("a",{parentName:"p",href:"./mutations"},Object(r.b)("inlineCode",{parentName:"a"},"useMutation")," hook")))}l.isMDXComponent=!0}}]);