(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{117:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return o})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return u}));var r=n(3),a=n(7),i=(n(0),n(142)),s={id:"ssr",title:"SSR"},o={unversionedId:"guides&concepts/ssr",id:"guides&concepts/ssr",isDocsHomePage:!1,title:"SSR",description:"React Query supports two ways of prefetching data on the server and passing that to the queryClient.",source:"@site/docs/guides&concepts/ssr.md",slug:"/guides&concepts/ssr",permalink:"/react-query-web-i18n/guides&concepts/ssr",editUrl:"https://github.com/cangSDARM/react-query-web-i18n/docs/guides&concepts/ssr.md",version:"current",lastUpdatedAt:1614595344,sidebar:"zhCN",previous:{title:"Query Filters",permalink:"/react-query-web-i18n/guides&concepts/query-filters"},next:{title:"Caching Examples",permalink:"/react-query-web-i18n/guides&concepts/caching"}},c=[{value:"Using Next.js",id:"using-nextjs",children:[{value:"Using <code>initialData</code>",id:"using-initialdata",children:[]},{value:"Using Hydration",id:"using-hydration",children:[]}]},{value:"Using Other Frameworks or Custom SSR Frameworks",id:"using-other-frameworks-or-custom-ssr-frameworks",children:[{value:"On the Server",id:"on-the-server",children:[]},{value:"Client",id:"client",children:[]}]},{value:"Tips, Tricks and Caveats",id:"tips-tricks-and-caveats",children:[{value:"Only successful queries are included in dehydration",id:"only-successful-queries-are-included-in-dehydration",children:[]},{value:"Staleness is measured from when the query was fetched on the server",id:"staleness-is-measured-from-when-the-query-was-fetched-on-the-server",children:[]}]}],l={toc:c};function u(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"React Query supports two ways of prefetching data on the server and passing that to the queryClient."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Prefetch the data yourself and pass it in as ",Object(i.b)("inlineCode",{parentName:"li"},"initialData"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Quick to set up for simple cases"),Object(i.b)("li",{parentName:"ul"},"Has some caveats"))),Object(i.b)("li",{parentName:"ul"},"Prefetch the query on the server, dehydrate the cache and rehydrate it on the client",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Requires slightly more setup up front")))),Object(i.b)("h2",{id:"using-nextjs"},"Using Next.js"),Object(i.b)("p",null,"The exact implementation of these mechanisms may vary from platform to platform, but we recommend starting with Next.js which supports ",Object(i.b)("a",{parentName:"p",href:"https://nextjs.org/docs/basic-features/data-fetching"},"2 forms of pre-rendering"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Static Generation (SSG)"),Object(i.b)("li",{parentName:"ul"},"Server-side Rendering (SSR)")),Object(i.b)("p",null,"React Query supports both of these forms of pre-rendering regardless of what platform you may be using"),Object(i.b)("h3",{id:"using-initialdata"},"Using ",Object(i.b)("inlineCode",{parentName:"h3"},"initialData")),Object(i.b)("p",null,"Together with Next.js's ",Object(i.b)("a",{parentName:"p",href:"https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation"},Object(i.b)("inlineCode",{parentName:"a"},"getStaticProps"))," or ",Object(i.b)("a",{parentName:"p",href:"https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering"},Object(i.b)("inlineCode",{parentName:"a"},"getServerSideProps")),", you can pass the data you fetch in either method to ",Object(i.b)("inlineCode",{parentName:"p"},"useQuery"),"'s' ",Object(i.b)("inlineCode",{parentName:"p"},"initialData")," option. From React Query's perspective, these integrate in the same way, ",Object(i.b)("inlineCode",{parentName:"p"},"getStaticProps")," is shown below:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"export async function getStaticProps() {\n  const posts = await getPosts()\n  return { props: { posts } }\n}\n\nfunction Posts(props) {\n  const { data } = useQuery('posts', getPosts, { initialData: props.posts })\n\n  // ...\n}\n")),Object(i.b)("p",null,"The setup is minimal and this can be a quick solution for some cases, but there are a ",Object(i.b)("strong",{parentName:"p"},"few tradeoffs to consider")," when compared to the full approach:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"If you are calling ",Object(i.b)("inlineCode",{parentName:"li"},"useQuery")," in a component deeper down in the tree you need to pass the ",Object(i.b)("inlineCode",{parentName:"li"},"initialData")," down to that point"),Object(i.b)("li",{parentName:"ul"},"If you are calling ",Object(i.b)("inlineCode",{parentName:"li"},"useQuery")," with the same query in multiple locations, you need to pass ",Object(i.b)("inlineCode",{parentName:"li"},"initialData")," to all of them"),Object(i.b)("li",{parentName:"ul"},"There is no way to know at what time the query was fetched on the server, so ",Object(i.b)("inlineCode",{parentName:"li"},"dataUpdatedAt")," and determining if the query needs refetching is based on when the page loaded instead")),Object(i.b)("h3",{id:"using-hydration"},"Using Hydration"),Object(i.b)("p",null,"React Query supports prefetching multiple queries on the server in Next.js and then ",Object(i.b)("em",{parentName:"p"},"dehydrating")," those queries to the queryClient. This means the server can prerender markup that is immediately available on page load and as soon as JS is available, React Query can upgrade or ",Object(i.b)("em",{parentName:"p"},"hydrate")," those queries with the full functionality of the library. This includes refetching those queries on the client if they have become stale since the time they were rendered on the server."),Object(i.b)("p",null,"To support caching queries on the server and set up hydration:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Create a new ",Object(i.b)("inlineCode",{parentName:"li"},"QueryClient")," instance ",Object(i.b)("strong",{parentName:"li"},"inside of your app, and on an instance ref. This ensures that data is not shared between different users and requests.")),Object(i.b)("li",{parentName:"ul"},"Wrap your app component with ",Object(i.b)("inlineCode",{parentName:"li"},"<QueryClientProvider>")," and pass it the client instance"),Object(i.b)("li",{parentName:"ul"},"Wrap your app component with ",Object(i.b)("inlineCode",{parentName:"li"},"<Hydrate>")," and pass it the ",Object(i.b)("inlineCode",{parentName:"li"},"dehydratedState")," prop from ",Object(i.b)("inlineCode",{parentName:"li"},"pageProps"))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"// _app.jsx\nimport { QueryClient, QueryClientProvider } from 'react-query'\nimport { Hydrate } from 'react-query/hydration'\n\nexport default function MyApp({ Component, pageProps }) {\n  const queryClientRef = React.useRef()\n  if (!queryClientRef.current) {\n    queryClientRef.current = new QueryClient()\n  }\n\n  return (\n    <QueryClientProvider client={queryClientRef.current}>\n      <Hydrate state={pageProps.dehydratedState}>\n        <Component {...pageProps} />\n      </Hydrate>\n    </QueryClientProvider>\n  )\n}\n")),Object(i.b)("p",null,"Now you are ready to prefetch some data in your pages with either ",Object(i.b)("a",{parentName:"p",href:"https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation"},Object(i.b)("inlineCode",{parentName:"a"},"getStaticProps"))," (for SSG) or ",Object(i.b)("a",{parentName:"p",href:"https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering"},Object(i.b)("inlineCode",{parentName:"a"},"getServerSideProps"))," (for SSR). From React Query's perspective, these integrate in the same way, ",Object(i.b)("inlineCode",{parentName:"p"},"getStaticProps")," is shown below."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Create a new ",Object(i.b)("inlineCode",{parentName:"li"},"QueryClient")," instance ",Object(i.b)("strong",{parentName:"li"},"for each page request. This ensures that data is not shared between users and requests.")),Object(i.b)("li",{parentName:"ul"},"Prefetch the data using the clients ",Object(i.b)("inlineCode",{parentName:"li"},"prefetchQuery")," method and wait for it to complete"),Object(i.b)("li",{parentName:"ul"},"Use ",Object(i.b)("inlineCode",{parentName:"li"},"dehydrate")," to dehydrate the query cache and pass it to the page via the ",Object(i.b)("inlineCode",{parentName:"li"},"dehydratedState")," prop. This is the same prop that the cache will be picked up from in your ",Object(i.b)("inlineCode",{parentName:"li"},"_app.js"))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"// pages/posts.jsx\nimport { QueryClient, useQuery } from 'react-query'\nimport { dehydrate } from 'react-query/hydration'\n\nexport async function getStaticProps() {\n  const queryClient = new QueryClient()\n\n  await queryClient.prefetchQuery('posts', getPosts)\n\n  return {\n    props: {\n      dehydratedState: dehydrate(queryClient),\n    },\n  }\n}\n\nfunction Posts() {\n  // This useQuery could just as well happen in some deeper child to\n  // the \"Posts\"-page, data will be available immediately either way\n  const { data } = useQuery('posts', getPosts)\n\n  // This query was not prefetched on the server and will not start\n  // fetching until on the client, both patterns are fine to mix\n  const { data: otherData } = useQuery('posts-2', getPosts)\n\n  // ...\n}\n")),Object(i.b)("p",null,"As demonstrated, it's fine to prefetch some queries and let others fetch on the queryClient. This means you can control what content server renders or not by adding or removing ",Object(i.b)("inlineCode",{parentName:"p"},"prefetchQuery")," for a specific query."),Object(i.b)("h2",{id:"using-other-frameworks-or-custom-ssr-frameworks"},"Using Other Frameworks or Custom SSR Frameworks"),Object(i.b)("p",null,"This guide is at-best, a high level overview of how SSR with React Query should work. Your mileage may vary since there are many different possible setups for SSR."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"If you can, please contribution your findings back to this page for any framework specific guidance!")),Object(i.b)("h3",{id:"on-the-server"},"On the Server"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Create a new ",Object(i.b)("inlineCode",{parentName:"li"},"QueryClient")," instance ",Object(i.b)("strong",{parentName:"li"},"inside of your request handler. This ensures that data is not shared between different users and requests.")),Object(i.b)("li",{parentName:"ul"},"Using the client, prefetch any data you need"),Object(i.b)("li",{parentName:"ul"},"Dehydrate the client"),Object(i.b)("li",{parentName:"ul"},"Render your app with the client provider and also ",Object(i.b)("strong",{parentName:"li"},"using the dehydrated state. This is extremely important! You must render both server and client using the same dehydrated state to ensure hydration on the client produces the exact same markup as the server.")),Object(i.b)("li",{parentName:"ul"},"Serialize and embed the dehydrated cache to be sent to the client with the HTML")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"SECURITY NOTE: Serializing data with ",Object(i.b)("inlineCode",{parentName:"p"},"JSON.stringify")," can put you at risk for XSS-vulnerabilities, ",Object(i.b)("a",{parentName:"p",href:"https://medium.com/node-security/the-most-common-xss-vulnerability-in-react-js-applications-2bdffbcc1fa0"},"this blog post explains why and how to solve it"))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"import { QueryClient, QueryClientProvider } from 'react-query'\nimport { dehydrate, Hydrate } from 'react-query/hydration'\n\nfunction handleRequest (req, res) {\n  const queryClient = new QueryClient()\n  await queryClient.prefetchQuery('key', fn)\n  const dehydratedState = dehydrate(queryClient)\n\n  const html = ReactDOM.renderToString(\n    <QueryClientProvider client={queryClient}>\n      <Hydrate state={dehydratedState}>\n        <App />\n      </Hydrate>\n    </QueryClientProvider>\n  )\n\n  res.send(`\n    <html>\n      <body>\n        <div id=\"root\">${html}</div>\n        <script>\n          window.__REACT_QUERY_STATE__ = ${JSON.stringify(dehydratedState)};\n        <\/script>\n      </body>\n    </html>\n  `)\n}\n")),Object(i.b)("h3",{id:"client"},"Client"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Parse the dehydrated cache state that was sent to the client with the HTML"),Object(i.b)("li",{parentName:"ul"},"Create a new ",Object(i.b)("inlineCode",{parentName:"li"},"QueryClient")," instance"),Object(i.b)("li",{parentName:"ul"},"Render your app with the client provider and also ",Object(i.b)("strong",{parentName:"li"},"using the dehydrated state. This is extremely important! You must render both server and client using the same dehydrated state to ensure hydration on the client produces the exact same markup as the server."))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"import { QueryClient, QueryClientProvider } from 'react-query'\nimport { Hydrate } from 'react-query/hydration'\n\nconst dehydratedState = window.__REACT_QUERY_STATE__\n\nconst queryClient = new QueryClient()\n\nReactDOM.hydrate(\n  <QueryClientProvider client={queryClient}>\n    <Hydrate state={dehydratedState}>\n      <App />\n    </Hydrate>\n  </QueryClientProvider>,\n  document.getElementById('root')\n)\n")),Object(i.b)("h2",{id:"tips-tricks-and-caveats"},"Tips, Tricks and Caveats"),Object(i.b)("h3",{id:"only-successful-queries-are-included-in-dehydration"},"Only successful queries are included in dehydration"),Object(i.b)("p",null,"Any query with an error is automatically excluded from dehydration. This means that the default behaviour is to pretend these queries were never loaded on the server, usually showing a loading state instead, and retrying the queries on the queryClient. This happens regardless of error."),Object(i.b)("p",null,"Sometimes this behavior is not desirable, maybe you want to render an error page with a correct status code instead on certain errors or queries. In those cases, use ",Object(i.b)("inlineCode",{parentName:"p"},"fetchQuery")," and catch any errors to handle those manually."),Object(i.b)("h3",{id:"staleness-is-measured-from-when-the-query-was-fetched-on-the-server"},"Staleness is measured from when the query was fetched on the server"),Object(i.b)("p",null,"A query is considered stale depending on when it was ",Object(i.b)("inlineCode",{parentName:"p"},"dataUpdatedAt"),". A caveat here is that the server needs to have the correct time for this to work properly, but UTC time is used, so timezones do not factor into this."),Object(i.b)("p",null,"Because ",Object(i.b)("inlineCode",{parentName:"p"},"staleTime")," defaults to ",Object(i.b)("inlineCode",{parentName:"p"},"0"),", queries will be refetched in the background on page load by default. You might want to use a higher ",Object(i.b)("inlineCode",{parentName:"p"},"staleTime")," to avoid this double fetching, especially if you don't cache your markup."),Object(i.b)("p",null,"This refetching of stale queries is a perfect match when caching markup in a CDN! You can set the cache time of the page itself decently high to avoid having to re-render pages on the server, but configure the ",Object(i.b)("inlineCode",{parentName:"p"},"staleTime")," of the queries lower to make sure data is refetched in the background as soon as a user visits the page. Maybe you want to cache the pages for a week, but refetch the data automatically on page load if it's older than a day?"))}u.isMDXComponent=!0},142:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return b}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),u=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=u(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},h=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=u(n),h=r,b=d["".concat(s,".").concat(h)]||d[h]||p[h]||i;return n?a.a.createElement(b,o(o({ref:t},l),{},{components:n})):a.a.createElement(b,o({ref:t},l))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=h;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var l=2;l<i;l++)s[l]=n[l];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);