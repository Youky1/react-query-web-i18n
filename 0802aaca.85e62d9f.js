(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{142:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return f}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),p=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,f=d["".concat(i,".").concat(m)]||d[m]||l[m]||o;return n?a.a.createElement(f,s(s({ref:t},c),{},{components:n})):a.a.createElement(f,s({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},64:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return u})),n.d(t,"default",(function(){return p}));var r=n(3),a=n(7),o=(n(0),n(142)),i={id:"updates-from-mutation-responses",title:"Updates from Mutation Responses"},s={unversionedId:"guides&concepts/updates-from-mutation-responses",id:"guides&concepts/updates-from-mutation-responses",isDocsHomePage:!1,title:"Updates from Mutation Responses",description:"When dealing with mutations that update objects on the server, it's common for the new object to be automatically returned in the response of the mutation. Instead of refetching any queries for that item and wasting a network call for data we already have, we can take advantage of the object returned by the mutation function and update the existing query with the new data immediately using the Query Client's setQueryData method:",source:"@site/docs/guides&concepts/updates-from-mutation-responses.md",slug:"/guides&concepts/updates-from-mutation-responses",permalink:"/react-query-web-i18n/guides&concepts/updates-from-mutation-responses",editUrl:"https://github.com/cangSDARM/react-query-web-i18n/docs/guides&concepts/updates-from-mutation-responses.md",version:"current",lastUpdatedAt:1614763020,sidebar:"zhCN",previous:{title:"\u4fee\u6539\u5bfc\u81f4\u7684\u91cd\u65b0\u6570\u636e\u68c0\u9a8c",permalink:"/react-query-web-i18n/guides&concepts/invalidation-from-mutations"},next:{title:"Optimistic Updates",permalink:"/react-query-web-i18n/guides&concepts/optimistic-updates"}},u=[],c={toc:u};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"When dealing with mutations that ",Object(o.b)("strong",{parentName:"p"},"update")," objects on the server, it's common for the new object to be automatically returned in the response of the mutation. Instead of refetching any queries for that item and wasting a network call for data we already have, we can take advantage of the object returned by the mutation function and update the existing query with the new data immediately using the ",Object(o.b)("a",{parentName:"p",href:"../reference/QueryClient#queryclientsetquerydata"},"Query Client's ",Object(o.b)("inlineCode",{parentName:"a"},"setQueryData"))," method:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js"},"const queryClient = useQueryClient()\n\nconst mutation = useMutation(editTodo, {\n  onSuccess: data => queryClient.setQueryData(['todo', { id: 5 }], data),\n})\n\nmutation.mutate({\n  id: 5,\n  name: 'Do the laundry',\n})\n\n// The query below will be updated with the response from the\n// successful mutation\nconst { status, data, error } = useQuery(['todo', { id: 5 }], fetchTodoByID)\n")),Object(o.b)("p",null,"You might want to tie the ",Object(o.b)("inlineCode",{parentName:"p"},"onSuccess")," logic into a reusable mutation, for that you can\ncreate a custom hook like this:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js"},"const useMutateTodo = () => {\n  const queryClient = useQueryClient()\n\n  return useMutation(editTodo, {\n    // Notice the second argument is the variables object that the `mutate` function receives\n    onSuccess: (data, variables) => {\n      queryClient.setQueryData(['todo', { id: variables.id }], data)\n    },\n  })\n}\n")))}p.isMDXComponent=!0}}]);