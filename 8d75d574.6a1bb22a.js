(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{108:function(e,n,r){"use strict";r.r(n),r.d(n,"frontMatter",(function(){return s})),r.d(n,"metadata",(function(){return i})),r.d(n,"toc",(function(){return u})),r.d(n,"default",(function(){return l}));var t=r(3),o=r(7),a=(r(0),r(142)),s={id:"suspense",title:"Suspense"},i={unversionedId:"guides&concepts/suspense",id:"guides&concepts/suspense",isDocsHomePage:!1,title:"Suspense",description:"NOTE: Suspense mode for React Query is experimental, same as Suspense for data fetching itself. These APIs WILL change and should not be used in production unless you lock both your React and React Query versions to patch-level versions that are compatible with each other.",source:"@site/docs/guides&concepts/suspense.md",slug:"/guides&concepts/suspense",permalink:"/react-query-web-i18n/guides&concepts/suspense",editUrl:"https://github.com/cangSDARM/react-query-web-i18n/docs/guides&concepts/suspense.md",version:"current",lastUpdatedAt:1614595344,sidebar:"zhCN",previous:{title:"Default Query Function",permalink:"/react-query-web-i18n/guides&concepts/default-query-function"},next:{title:"Testing",permalink:"/react-query-web-i18n/guides&concepts/testing"}},u=[{value:"Resetting Error Boundaries",id:"resetting-error-boundaries",children:[]},{value:"Fetch-on-render vs Render-as-you-fetch",id:"fetch-on-render-vs-render-as-you-fetch",children:[]}],c={toc:u};function l(e){var n=e.components,r=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(t.a)({},c,r,{components:n,mdxType:"MDXLayout"}),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"NOTE: Suspense mode for React Query is experimental, same as Suspense for data fetching itself. These APIs WILL change and should not be used in production unless you lock both your React and React Query versions to patch-level versions that are compatible with each other.")),Object(a.b)("p",null,"React Query can also be used with React's new Suspense for Data Fetching API's. To enable this mode, you can set either the global or query level config's ",Object(a.b)("inlineCode",{parentName:"p"},"suspense")," option to ",Object(a.b)("inlineCode",{parentName:"p"},"true"),"."),Object(a.b)("p",null,"Global configuration:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js"},"// Configure for all queries\nimport { QueryClient, QueryClientProvider } from 'react-query'\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      suspense: true,\n    },\n  },\n})\n\nfunction Root() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <App />\n    </QueryClientProvider>\n  )\n}\n")),Object(a.b)("p",null,"Query configuration:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js"},"import { useQuery } from 'react-query'\n\n// Enable for an individual query\nuseQuery(queryKey, queryFn, { suspense: true })\n")),Object(a.b)("p",null,"When using suspense mode, ",Object(a.b)("inlineCode",{parentName:"p"},"status")," states and ",Object(a.b)("inlineCode",{parentName:"p"},"error")," objects are not needed and are then replaced by usage of the ",Object(a.b)("inlineCode",{parentName:"p"},"React.Suspense")," component (including the use of the ",Object(a.b)("inlineCode",{parentName:"p"},"fallback")," prop and React error boundaries for catching errors). Please read the ",Object(a.b)("a",{parentName:"p",href:"#resetting-error-boundaries"},"Resetting Error Boundaries")," and look at the ",Object(a.b)("a",{parentName:"p",href:"https://codesandbox.io/s/github/tannerlinsley/react-query/tree/master/examples/suspense"},"Suspense Example")," for more information on how to set up suspense mode."),Object(a.b)("p",null,"In addition to queries behaving differently in suspense mode, mutations also behave a bit differently. By default, instead of supplying the ",Object(a.b)("inlineCode",{parentName:"p"},"error")," variable when a mutation fails, it will be thrown during the next render of the component it's used in and propagate to the nearest error boundary, similar to query errors. If you wish to disable this, you can set the ",Object(a.b)("inlineCode",{parentName:"p"},"useErrorBoundary")," option to ",Object(a.b)("inlineCode",{parentName:"p"},"false"),". If you wish that errors are not thrown at all, you can set the ",Object(a.b)("inlineCode",{parentName:"p"},"throwOnError")," option to ",Object(a.b)("inlineCode",{parentName:"p"},"false")," as well!"),Object(a.b)("h2",{id:"resetting-error-boundaries"},"Resetting Error Boundaries"),Object(a.b)("p",null,"Whether you are using ",Object(a.b)("strong",{parentName:"p"},"suspense")," or ",Object(a.b)("strong",{parentName:"p"},"useErrorBoundaries")," in your queries, you will need a way to let queries know that you want to try again when re-rendering after some error occured."),Object(a.b)("p",null,"Query errors can be reset with the ",Object(a.b)("inlineCode",{parentName:"p"},"QueryErrorResetBoundary")," component or with the ",Object(a.b)("inlineCode",{parentName:"p"},"useQueryErrorResetBoundary")," hook."),Object(a.b)("p",null,"When using the component it will reset any query errors within the boundaries of the component:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js"},"import { QueryErrorResetBoundary } from 'react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nconst App: React.FC = () => (\n  <QueryErrorResetBoundary>\n    {({ reset }) => (\n      <ErrorBoundary\n        onReset={reset}\n        fallbackRender={({ resetErrorBoundary }) => (\n          <div>\n            There was an error!\n            <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n          </div>\n        )}\n      >\n        <Page />\n      </ErrorBoundary>\n    )}\n  </QueryErrorResetBoundary>\n)\n")),Object(a.b)("p",null,"When using the hook it will reset any query errors within the closest ",Object(a.b)("inlineCode",{parentName:"p"},"QueryErrorResetBoundary"),". If there is no boundary defined it will reset them globally:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-js"},"import { useQueryErrorResetBoundary } from 'react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nconst App: React.FC = () => {\n  const { reset } = useQueryErrorResetBoundary()\n  return (\n    <ErrorBoundary\n      onReset={reset}\n      fallbackRender={({ resetErrorBoundary }) => (\n        <div>\n          There was an error!\n          <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n        </div>\n      )}\n    >\n      <Page />\n    </ErrorBoundary>\n  )\n}\n")),Object(a.b)("h2",{id:"fetch-on-render-vs-render-as-you-fetch"},"Fetch-on-render vs Render-as-you-fetch"),Object(a.b)("p",null,"Out of the box, React Query in ",Object(a.b)("inlineCode",{parentName:"p"},"suspense")," mode works really well as a ",Object(a.b)("strong",{parentName:"p"},"Fetch-on-render")," solution with no additional configuration. This means that when your components attempt to mount, they will trigger query fetching and suspend, but only once you have imported them and mounted them. If you want to take it to the next level and implement a ",Object(a.b)("strong",{parentName:"p"},"Render-as-you-fetch")," model, we recommend implementing ",Object(a.b)("a",{parentName:"p",href:"./prefetching"},"Prefetching")," on routing callbacks and/or user interactions events to start loading queries before they are mounted and hopefully even before you start importing or mounting their parent components."))}l.isMDXComponent=!0},142:function(e,n,r){"use strict";r.d(n,"a",(function(){return p})),r.d(n,"b",(function(){return y}));var t=r(0),o=r.n(t);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function s(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function i(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?s(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function u(e,n){if(null==e)return{};var r,t,o=function(e,n){if(null==e)return{};var r,t,o={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=o.a.createContext({}),l=function(e){var n=o.a.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):i(i({},n),e)),r},p=function(e){var n=l(e.components);return o.a.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},b=o.a.forwardRef((function(e,n){var r=e.components,t=e.mdxType,a=e.originalType,s=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),p=l(r),b=t,y=p["".concat(s,".").concat(b)]||p[b]||d[b]||a;return r?o.a.createElement(y,i(i({ref:n},c),{},{components:r})):o.a.createElement(y,i({ref:n},c))}));function y(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var a=r.length,s=new Array(a);s[0]=b;var i={};for(var u in n)hasOwnProperty.call(n,u)&&(i[u]=n[u]);i.originalType=e,i.mdxType="string"==typeof e?e:t,s[1]=i;for(var c=2;c<a;c++)s[c]=r[c];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,r)}b.displayName="MDXCreateElement"}}]);