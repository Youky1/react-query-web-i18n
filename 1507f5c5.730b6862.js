(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{142:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),u=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=u(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},p=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=u(n),p=a,m=d["".concat(r,".").concat(p)]||d[p]||b[p]||i;return n?o.a.createElement(m,s(s({ref:t},l),{},{components:n})):o.a.createElement(m,s({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var l=2;l<i;l++)r[l]=n[l];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},66:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return u}));var a=n(3),o=n(7),i=(n(0),n(142)),r={id:"mutations",title:"\u4fee\u6539"},s={unversionedId:"guides&concepts/mutations",id:"guides&concepts/mutations",isDocsHomePage:!1,title:"\u4fee\u6539",description:"Unlike queries, mutations are typically used to create/update/delete data or perform server side-effects. For this purpose, React Query exports a useMutation hook.",source:"@site/docs/guides&concepts/mutations.md",slug:"/guides&concepts/mutations",permalink:"/react-query-web-i18n/guides&concepts/mutations",editUrl:"https://github.com/cangSDARM/react-query-web-i18n/docs/guides&concepts/mutations.md",version:"current",lastUpdatedAt:1614595344,sidebar:"zhCN",previous:{title:"\u9884\u53d6\u6570\u636e",permalink:"/react-query-web-i18n/guides&concepts/prefetching"},next:{title:"Query Invalidation",permalink:"/react-query-web-i18n/guides&concepts/query-invalidation"}},c=[{value:"Resetting Mutation State",id:"resetting-mutation-state",children:[]},{value:"Mutation Side Effects",id:"mutation-side-effects",children:[]},{value:"Promises",id:"promises",children:[]},{value:"Retry",id:"retry",children:[]},{value:"Persist mutations",id:"persist-mutations",children:[]}],l={toc:c};function u(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Unlike queries, mutations are typically used to create/update/delete data or perform server side-effects. For this purpose, React Query exports a ",Object(i.b)("inlineCode",{parentName:"p"},"useMutation")," hook."),Object(i.b)("p",null,"Here's an example of a mutation that adds a new todo to the server:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"function App() {\n  const mutation = useMutation(newTodo => axios.post('/todos', newTodo))\n\n  return (\n    <div>\n      {mutation.isLoading ? (\n        'Adding todo...'\n      ) : (\n        <>\n          {mutation.isError ? (\n            <div>An error occurred: {mutation.error.message}</div>\n          ) : null}\n\n          {mutation.isSuccess ? <div>Todo added!</div> : null}\n\n          <button\n            onClick={() => {\n              mutation.mutate({ id: new Date(), title: 'Do Laundry' })\n            }}\n          >\n            Create Todo\n          </button>\n        </>\n      )}\n    </div>\n  )\n}\n")),Object(i.b)("p",null,"A mutation can only be in one of the following states at any given moment:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"isIdle")," or ",Object(i.b)("inlineCode",{parentName:"li"},"status === 'idle'")," - The mutation is currently idle or in a fresh/reset state"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"isLoading")," or ",Object(i.b)("inlineCode",{parentName:"li"},"status === 'loading'")," - The mutation is currently running"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"isError")," or ",Object(i.b)("inlineCode",{parentName:"li"},"status === 'error'")," - The mutation encountered an error"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"isSuccess")," or ",Object(i.b)("inlineCode",{parentName:"li"},"status === 'success'")," - The mutation was successful and mutation data is available")),Object(i.b)("p",null,"Beyond those primary state, more information is available depending on the state the mutation:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"error")," - If the mutation is in an ",Object(i.b)("inlineCode",{parentName:"li"},"isError")," state, the error is available via the ",Object(i.b)("inlineCode",{parentName:"li"},"error")," property."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"data")," - If the mutation is in a ",Object(i.b)("inlineCode",{parentName:"li"},"success")," state, the data is available via the ",Object(i.b)("inlineCode",{parentName:"li"},"data")," property.")),Object(i.b)("p",null,"In the example above, you also saw that you can pass variables to your mutations function by calling the ",Object(i.b)("inlineCode",{parentName:"p"},"mutate")," function with a ",Object(i.b)("strong",{parentName:"p"},"single variable or object"),"."),Object(i.b)("p",null,"Even with just variables, mutations aren't all that special, but when used with the ",Object(i.b)("inlineCode",{parentName:"p"},"onSuccess")," option, the ",Object(i.b)("a",{parentName:"p",href:"../reference/QueryClient#queryclientinvalidatequeries"},"Query Client's ",Object(i.b)("inlineCode",{parentName:"a"},"invalidateQueries")," method")," and the ",Object(i.b)("a",{parentName:"p",href:"../reference/QueryClient#queryclientsetquerydata"},"Query Client's ",Object(i.b)("inlineCode",{parentName:"a"},"setQueryData")," method"),", mutations become a very powerful tool."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"IMPORTANT: The ",Object(i.b)("inlineCode",{parentName:"p"},"mutate")," function is an asynchronous function, which means you cannot use it directly in an event callback. If you need to access the event in ",Object(i.b)("inlineCode",{parentName:"p"},"onSubmit")," you need to wrap ",Object(i.b)("inlineCode",{parentName:"p"},"mutate")," in another function. This is due to ",Object(i.b)("a",{parentName:"p",href:"https://reactjs.org/docs/events.html#event-pooling"},"React event pooling"),".")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"// This will not work\nconst CreateTodo = () => {\n  const mutation = useMutation(event => {\n    event.preventDefault()\n    return fetch('/api', new FormData(event.target))\n  })\n\n  return <form onSubmit={mutation.mutate}>...</form>\n}\n\n// This will work\nconst CreateTodo = () => {\n  const mutation = useMutation(formData => {\n    return fetch('/api', formData)\n  })\n  const onSubmit = event => {\n    event.preventDefault()\n    mutation.mutate(new FormData(event.target))\n  }\n\n  return <form onSubmit={onSubmit}>...</form>\n}\n")),Object(i.b)("h2",{id:"resetting-mutation-state"},"Resetting Mutation State"),Object(i.b)("p",null,"It's sometimes the case that you need to clear the ",Object(i.b)("inlineCode",{parentName:"p"},"error")," or ",Object(i.b)("inlineCode",{parentName:"p"},"data")," of a mutation request. To do this, you can use the ",Object(i.b)("inlineCode",{parentName:"p"},"reset")," function to handle this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},'const CreateTodo = () => {\n  const [title, setTitle] = useState(\'\')\n  const mutation = useMutation(createTodo)\n\n  const onCreateTodo = e => {\n    e.preventDefault()\n    mutation.mutate({ title })\n  }\n\n  return (\n    <form onSubmit={onCreateTodo}>\n      {mutation.error && (\n        <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>\n      )}\n      <input\n        type="text"\n        value={title}\n        onChange={e => setTitle(e.target.value)}\n      />\n      <br />\n      <button type="submit">Create Todo</button>\n    </form>\n  )\n}\n')),Object(i.b)("h2",{id:"mutation-side-effects"},"Mutation Side Effects"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"useMutation")," comes with some helper options that allow quick and easy side-effects at any stage during the mutation lifecycle. These come in handy for both ",Object(i.b)("a",{parentName:"p",href:"./invalidation-from-mutations"},"invalidating and refetching queries after mutations")," and even ",Object(i.b)("a",{parentName:"p",href:"./optimistic-updates"},"optimistic updates")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"useMutation(addTodo, {\n  onMutate: variables => {\n    // A mutation is about to happen!\n\n    // Optionally return a context containing data to use when for example rolling back\n    return { id: 1 }\n  },\n  onError: (error, variables, context) => {\n    // An error happened!\n    console.log(`rolling back optimistic update with id ${context.id}`)\n  },\n  onSuccess: (data, variables, context) => {\n    // Boom baby!\n  },\n  onSettled: (data, error, variables, context) => {\n    // Error or success... doesn't matter!\n  },\n})\n")),Object(i.b)("p",null,"When returning a promise in any of the callback functions it will first be awaited before the next callback is called:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},'useMutation(addTodo, {\n  onSuccess: async () => {\n    console.log("I\'m first!")\n  },\n  onSettled: async () => {\n    console.log("I\'m second!")\n  },\n})\n')),Object(i.b)("p",null,"You might find that you want to ",Object(i.b)("strong",{parentName:"p"},"trigger additional callbacks")," then the ones defined on ",Object(i.b)("inlineCode",{parentName:"p"},"useMutation")," when calling ",Object(i.b)("inlineCode",{parentName:"p"},"mutate"),". This can be used to trigger component specific side effects. To do that, you can provide any of the same callback options to the ",Object(i.b)("inlineCode",{parentName:"p"},"mutate")," function after your mutation variable. Supported overrides include: ",Object(i.b)("inlineCode",{parentName:"p"},"onSuccess"),", ",Object(i.b)("inlineCode",{parentName:"p"},"onError")," and ",Object(i.b)("inlineCode",{parentName:"p"},"onSettled"),"."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"useMutation(addTodo, {\n  onSuccess: (data, variables, context) => {\n    // I will fire first\n  },\n  onError: (error, variables, context) => {\n    // I will fire first\n  },\n  onSettled: (data, error, variables, context) => {\n    // I will fire first\n  },\n})\n\nmutate(todo, {\n  onSuccess: (data, variables, context) => {\n    // I will fire second!\n  },\n  onError: (error, variables, context) => {\n    // I will fire second!\n  },\n  onSettled: (data, error, variables, context) => {\n    // I will fire second!\n  },\n})\n")),Object(i.b)("h2",{id:"promises"},"Promises"),Object(i.b)("p",null,"Use ",Object(i.b)("inlineCode",{parentName:"p"},"mutateAsync")," instead of ",Object(i.b)("inlineCode",{parentName:"p"},"mutate")," to get a promise which will resolve on success or throw on an error. This can for example be used to compose side effects."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"const mutation = useMutation(addTodo)\n\ntry {\n  const todo = await mutation.mutateAsync(todo)\n  console.log(todo)\n} catch (error) {\n  console.error(error)\n} finally {\n  console.log('done')\n}\n")),Object(i.b)("h2",{id:"retry"},"Retry"),Object(i.b)("p",null,"By default React Query will not retry a mutation on error, but it is possible with the ",Object(i.b)("inlineCode",{parentName:"p"},"retry")," option:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"const mutation = useMutation(addTodo, {\n  retry: 3,\n})\n")),Object(i.b)("p",null,"If mutations fail because the device is offline, they will be retried in the same order when the device reconnects."),Object(i.b)("h2",{id:"persist-mutations"},"Persist mutations"),Object(i.b)("p",null,"Mutations can be persisted to storage if needed and resumed at a later point. This can be done with the hydration functions:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-js"},"const queryClient = new QueryClient()\n\n// Define the \"addTodo\" mutation\nqueryClient.setMutationDefaults('addTodo', {\n  mutationFn: addTodo,\n  onMutate: async (variables) => {\n    // Cancel current queries for the todos list\n    await queryClient.cancelQueries('todos')\n\n    // Create optimistic todo\n    const optimisticTodo = { id: uuid(), title: variables.title }\n\n    // Add optimistic todo to todos list\n    queryClient.setQueryData('todos', old => [...old, optimisticTodo])\n\n    // Return context with the optimistic todo\n    return { optimisticTodo }\n  },\n  onSuccess: (result, variables, context) => {\n    // Replace optimistic todo in the todos list with the result\n    queryClient.setQueryData('todos', old => old.map(todo => todo.id === context.optimisticTodo.id ? result : todo))\n  },\n  onError: (error, variables, context) => {\n    // Remove optimistic todo from the todos list\n    queryClient.setQueryData('todos', old => old.filter(todo => todo.id !== context.optimisticTodo.id))\n  },\n  retry: 3,\n})\n\n// Start mutation in some component:\nconst mutation = useMutation('addTodo')\nmutation.mutate({ title: 'title' })\n\n// If the mutation has been paused because the device is for example offline,\n// Then the paused mutation can be dehydrated when the application quits:\nconst state = dehydrate(queryClient)\n\n// The mutation can then be hydrated again when the application is started:\nhydrate(queryClient, state)\n\n// Resume the paused mutations:\nqueryClient.resumePausedMutations()\n")))}u.isMDXComponent=!0}}]);