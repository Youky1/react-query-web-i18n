"use strict";(self.webpackChunkreact_query_web_i18n=self.webpackChunkreact_query_web_i18n||[]).push([[7275],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return y}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),d=u(n),y=r,m=d["".concat(o,".").concat(y)]||d[y]||p[y]||l;return n?a.createElement(m,i(i({ref:t},s),{},{components:n})):a.createElement(m,i({ref:t},s))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=d;var c={};for(var o in t)hasOwnProperty.call(t,o)&&(c[o]=t[o]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},745:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return o},metadata:function(){return u},toc:function(){return s},default:function(){return d}});var a=n(7462),r=n(3366),l=(n(7294),n(3905)),i=["components"],c={id:"QueryCache",title:"QueryCache"},o=void 0,u={unversionedId:"reference/QueryCache",id:"reference/QueryCache",title:"QueryCache",description:"The QueryCache is the storage mechanism for React Query. It stores all the data, meta information and state of queries it contains.",source:"@site/docs/reference/QueryCache.md",sourceDirName:"reference",slug:"/reference/QueryCache",permalink:"/react-query-web-i18n/reference/QueryCache",editUrl:"https://github.com/cangSDARM/react-query-web-i18n/docs/reference/QueryCache.md",tags:[],version:"current",lastUpdatedAt:1643295702,formattedLastUpdatedAt:"1/27/2022",frontMatter:{id:"QueryCache",title:"QueryCache"}},s=[{value:"Global callbacks",id:"global-callbacks",children:[],level:2},{value:"<code>queryCache.find</code>",id:"querycachefind",children:[],level:2},{value:"<code>queryCache.findAll</code>",id:"querycachefindall",children:[],level:2},{value:"<code>queryCache.subscribe</code>",id:"querycachesubscribe",children:[],level:2},{value:"<code>queryCache.clear</code>",id:"querycacheclear",children:[],level:2}],p={toc:s};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"QueryCache")," is the storage mechanism for React Query. It stores all the data, meta information and state of queries it contains."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Normally, you will not interact with the QueryCache directly and instead use the ",(0,l.kt)("inlineCode",{parentName:"strong"},"QueryClient")," for a specific cache.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'import { QueryCache } from "react-query";\n\nconst queryCache = new QueryCache({\n  onError: (error) => {\n    console.log(error);\n  },\n  onSuccess: (data) => {\n    console.log(data);\n  },\n});\n\nconst query = queryCache.find("posts");\n')),(0,l.kt)("p",null,"Its available methods are:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#global-callbacks"},"Global callbacks")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#querycachefind"},(0,l.kt)("inlineCode",{parentName:"a"},"queryCache.find"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#querycachefindall"},(0,l.kt)("inlineCode",{parentName:"a"},"queryCache.findAll"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#querycachesubscribe"},(0,l.kt)("inlineCode",{parentName:"a"},"queryCache.subscribe"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#querycacheclear"},(0,l.kt)("inlineCode",{parentName:"a"},"queryCache.clear")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Options")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"onError?: (error: unknown, query: Query) => void"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Optional"),(0,l.kt)("li",{parentName:"ul"},"This function will be called if some query encounters an error."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"onSuccess?: (data: unknown, query: Query) => void"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Optional"),(0,l.kt)("li",{parentName:"ul"},"This function will be called if some query is successful.")))),(0,l.kt)("h2",{id:"global-callbacks"},"Global callbacks"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"onError")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"onSuccess")," callbacks on the QueryCache can be used to handle these events on a global level. They are different to ",(0,l.kt)("inlineCode",{parentName:"p"},"defaultOptions")," provided to the QueryClient because:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"defaultOptions")," can be overridden by each Query - the global callbacks will ",(0,l.kt)("strong",{parentName:"li"},"always")," be called."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"defaultOptions")," callbacks will be called once for each Observer, while the global callbacks will only be called once per Query.")),(0,l.kt)("h2",{id:"querycachefind"},(0,l.kt)("inlineCode",{parentName:"h2"},"queryCache.find")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"find")," is a slightly more advanced synchronous method that can be used to get an existing query instance from the cache. This instance not only contains ",(0,l.kt)("strong",{parentName:"p"},"all")," the state for the query, but all of the instances, and underlying guts of the query as well. If the query does not exist, ",(0,l.kt)("inlineCode",{parentName:"p"},"undefined")," will be returned."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Note: This is not typically needed for most applications, but can come in handy when needing more information about a query in rare scenarios (eg. Looking at the query.state.dataUpdatedAt timestamp to decide whether a query is fresh enough to be used as an initial value)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const query = queryCache.find(queryKey);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Options")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"queryKey?: QueryKey"),": ",(0,l.kt)("a",{parentName:"li",href:"../guides&concepts/query-keys"},"Query Keys")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"filters?: QueryFilters"),": ",(0,l.kt)("a",{parentName:"li",href:"/react-query-web-i18n/guides&concepts/filters"},"Query Filters"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Query"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The query instance from the cache")))),(0,l.kt)("h2",{id:"querycachefindall"},(0,l.kt)("inlineCode",{parentName:"h2"},"queryCache.findAll")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"findAll")," is even more advanced synchronous method that can be used to get existing query instances from the cache that partially match query key. If queries do not exist, empty array will be returned."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Note: This is not typically needed for most applications, but can come in handy when needing more information about a query in rare scenarios")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const queries = queryCache.findAll(queryKey);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Options")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"queryKey?: QueryKey"),": ",(0,l.kt)("a",{parentName:"li",href:"../guides&concepts/query-keys"},"Query Keys")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"filters?: QueryFilters"),": ",(0,l.kt)("a",{parentName:"li",href:"/react-query-web-i18n/guides&concepts/filters"},"Query Filters"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Query[]"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Query instances from the cache")))),(0,l.kt)("h2",{id:"querycachesubscribe"},(0,l.kt)("inlineCode",{parentName:"h2"},"queryCache.subscribe")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"subscribe")," method can be used to subscribe to the query cache as a whole and be informed of safe/known updates to the cache like query states changing or queries being updated, added or removed"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"const callback = (event) => {\n  console.log(event.type, event.query);\n};\n\nconst unsubscribe = queryCache.subscribe(callback);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Options")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"callback: (query?: Query) => void"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"This function will be called with the query cache any time it is updated via its tracked update mechanisms (eg, ",(0,l.kt)("inlineCode",{parentName:"li"},"query.setState"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"queryClient.removeQueries"),", etc). Out of scope mutations to the cache are not encouraged and will not fire subscription callbacks"),(0,l.kt)("li",{parentName:"ul"},"Additionally, for updates to the cache triggered by a specific query, the ",(0,l.kt)("inlineCode",{parentName:"li"},"query")," will be passed as first argument to the callback")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"unsubscribe: Function => void"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"This function will unsubscribe the callback from the query cache.")))),(0,l.kt)("h2",{id:"querycacheclear"},(0,l.kt)("inlineCode",{parentName:"h2"},"queryCache.clear")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"clear")," method can be used to clear the cache entirely and start fresh."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"queryCache.clear();\n")))}d.isMDXComponent=!0}}]);