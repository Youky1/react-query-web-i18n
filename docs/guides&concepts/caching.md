---
id: caching
title: 缓存 Caching
tags:
  - 翻译完成
---

> 在阅读本篇文档之前，请认真阅读[重要的默认配置](./important-defaults)

## 基础

此段说明了以下内容和其生命周期：

- 查询有和没有缓存数据的实例
- 后台重新拉取
- 不活跃的查询
- 垃圾回收

假设我们使用的默认`cacheTime`为**5 分钟**，默认的`staleTime`为`0`。

- 一个新的`useQuery(['todos'], fetchTodos)`实例被挂载
  - 由于没有使用`['todos']`作为键值的其他查询，该查询将显示硬加载状态，并发出网络请求以获取数据
  - 当网络请求完成后，将`['todos']`键作为缓存的唯一标识符缓存数据
  - 在配置的`staleTime`（默认为`0`或立即）之后，该 Hook 会将对应的数据标记为过时
- 第二个`useQuery(['todos'], fetchTodos)`实例挂载在其他位置
  - 由于该查询的第一个实例的数据已被`['todos']`存在于缓存中，因此该数据将立即从缓存返回
  - 新实例使用其查询函数触发新的网络请求（注意请求只有一个）
    - 注意，无论两个`fetchTodos`查询函数是否相同，两个查询的状态都会更新(包括 `isfetch`、`isLoading` 和其他相关值)。因为它们具有相同的查询键值
  - 当请求成功完成时，`['todos']`键值对应的缓存数据将被更新，两个实例也将被同步更新
- 两个`useQuery(['todos'], fetchTodos)`查询的实例都已被卸载，并且不再使用
  - 由于此查询没有更多活动实例，因此在`cacheTime`设置的缓存超时时间之后，来删除查询并对其进行垃圾回收（默认为**5 分钟**）
- 在缓存超时完成之前，挂载另一个`useQuery(['todos'], fetchTodos)`实例
  - 当`fetchTodos`函数在后台运行时，该查询立即返回可用的缓存值，和第二种情况类似，当它成功完成时，它将用新数据来填充缓存并更新实例
- `useQuery(['todos'], fetchTodos)`的最后一个实例卸载
- **5 分钟**内没有再出现`useQuery(['todos'], fetchTodos)`的实例
  - 该查询及其缓存数据将被删除并进行垃圾回收
